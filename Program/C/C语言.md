# 概念
## [计算机语言](https://www.tiobe.com/tiobe-index/)
1. 编译型语言
2. 通过编译器和链接器生成二进制的可执行文件
3. VS：集成开发环境MSVC
## main函数
1. 入口
2. 同一个项目不管多少.c文件有且只有一个
## [库函数](https://cplusplus.com/reference/clibrary/)
## [关键字](https://zh.cppreference.com/w/c/keyword)
1. 又叫做保留字
2. 特殊意义，C语言自己使用的
3. 创建标识符不能和关键字重复
4. 不能自己创建
## 字符和[ASCII编码](https://zh.cppreference.com/w/cpp/language/ascii)
1. A\~Z：65\~90
2. a\~z：97\~122
3. 0\~9：48\~57
4. \n：10
5. 0~31这32个字符是不能打印在屏幕的
## 字符串和\0
1. %s，也可已省略
2. 字符串末尾隐藏一个\0，\0是字符串的隐藏结束标志，\0是占据字符串和字符数组长度的
3. 如果末尾没有\0，会以乱码结束打印
## [转义字符](https://zh.cppreference.com/w/c/language/escape)
1. \ddd：8进制
2. \xdd：16进制
## 语句
1. 空语句
	1. ;
2. 表达式语句
	2. int a = 0;
3. 函数调用语句
	1. prtinf();
4. 复合语句
	2. {}
5. 控制语句
	1. 条件判断/分支语句
		1. if
		2. switch
	2. 循环语句
		1. for
		2. while
		3. do while
	3. 转向语句
		1. break
		2. goto
		3. continue
		4. return

## 注释

# 数据类型和变量

## 数据类型
1. 内置类型
	1. 字符型（整型的一种）
	2. 整型
	3. 浮点型
	4. 布尔型
2. 自定义类型
	1. 数组
	2. 结构体struct
	3. 枚举enum
	4. 联合体union
## unsigned和signed
1. signed int和int相同
2. signed char和char不同
## 字符型char
1. unsinged char
2. singed char

## 整型
1. unsigned
	1. unsigned short int
	2. unsigned int
	3. unsigned long int
	4. unsigned long long int
2. signed
	1. short int
	2. int
	3. long int
	4. long long int
## 浮点型
1. float
2. double
3. long double
## 布尔类型：\_Bool/bool
## sizeof：
    1. 计算字符长度
	2. 后面的表达式不参与运算
	3. 计算结果是size_t类型
	4. %zd
## 数据类型取值范围
1. limits.h
2. float.h
3. 常量
	1. SCHAR_MAX
	2. SHRT_MAX
	3. INT_MAX
	4. LONG_MAX
	5. LLONG_MAX
	6. UCHAR_MAX
	7. USHART_MAX
	8. UINT_MAX
	9. ULONG_MAX
	10. ULLONG_MAX
## 变量 
1. 全局：静态区
2. 局部：栈区
## 强制类型转换：int a=(int)3.14

## [占位符](https://blog.csdn.net/Gao123456fy/article/details/134750608)
1. printf
2. %5d：输出五位，不够前面空格补齐，右对齐
3. %-5d：左对齐
4. %12f：小数点后默认占一半，小数点算1位
5. %+d：确保总是带符号
6. %.2f：保留两位小数
7. %6.2f：总6位，小数2位
	1. %\*.\*f：printf("%\*.\*f",6,2)
8. %c
	1. 不忽略空白字符，因为空白字符也是字符变量的一种
	2. 如果要忽略“ %c”，前面加空格表示忽略一个或多个空格
9. %s
	1. 遇到空白字符停止\0
	2. 末尾会存储一个\0：所以要防止越界
	3. 指定读取的最大长度：%\[m]s：m代表读取的最大长度，为了防止越界，m通常为数组长度-1，为\0预留空间
10. 赋值忽略符*：%\*c，会忽略c这个占位符

## scanf

1. 处理占位符时，会自动略过
	1. 空格
	2. 制表符
	3. 换行符
2. 连续使用scanf会从上次遗留的读取
	4. 输入：-12.3456#
		1. scanf("%d",x)：-12
		2. printf
	5. 输入：# 0
		1. scanf("%f",y)
		2. printf
	6. 输出：x=-12，y=0.3456
# 分支与循环
## 循环语句
1. while()
2. for(exp1;exp2;exp3){}
	1. exp1：初始化循环变量
	2. exp2：设置循环结束的条件
	3. exp3：调整循环变量
3. do{}while();
	1. 必执行一次
## 条件/分支语句
1. if  elseif   else
	1. 0为假，非0为真
	2. 只控制下方一条语句，多条用{}
	3. else总是跟最近的if匹配
2. switch(){case 1:break;case 2: break}
	1. 需要加break才能跳出，否则会顺序执行后续
	2. case和后面的数字需要加空格
	3. default：输入值无法匹配时，执行default，通常放在最后，但不强制
## 转向语句
1. break：永久终止循环
2. continue：终止本次循环，不执行本次循环的后续代码
3. goto  自定义标识符：跳转到自定义标识符处

# 数组

## 概念

1.同一类型的多个元素
2.元素个数不能为0
3.类型：去掉数组名
## 一维数组
### 创建、初始化、类型
1. 创建：type name[常量值]
	常量值可省略，但长度由初始化的个数决定
2. 类型：type [常量值]
3. 初始化
	1. 完全初始化
	2. 不完全初始化：未初始化的补0
### 内存
1.连续存放
2.sizeof()计算数组大小
## 二维数组
### 概念

1.一维数组作为数组的元素就叫做二维数组
2.二维数组作为数组的元素就叫做三维数组
3.三维数组以上的叫做多维数组

### 创建

1.type name\[行常量值]\[列常量值]
	name\[行常量值]就是一维数组的名字
2.行常量值可省略，列不能省略
3.类型：type\[行常量值]\[列常量值]

### 初始化
1.完全初始化
2.未完全初始化
	1.作为元素的一维数组也可以完全初始化或者部分初始化
	2.未初始化的补0
	3.可以按照行进行未完全初始化

### 内存

1.自左向右依次连续存放
2.先行后列
# 函数

## 概念
1. 子程序
2. 完成某种特定任务

## 分类

1. 库函数
2. 自定义函数

## 库函数

1.\[头文件]
	1. [C 标准库头文件 - cppreference.com](https://zh.cppreference.com/w/c/header)
	2. [C 库 - C++ 参考](https://legacy.cplusplus.com/reference/clibrary/)

## 函数结构

1. ret_type func_name(形参){}
2. 形参和实参
	1. 不调用函数时不存在形参，调用时形参进行实例化
	2. 个数和类型是相同的
	3. 具有不同的内存空间
	4. 形参实际上是实参的一份临时拷贝，值相同但是地址不同
3. return
	1. 可以跟数值
	2. 可以跟表达式：先执行表达式然后返回表达式的值
	3. 空：void类型
	4. 如果存在if等条件判断，每个结果都要有return
4. 数组
	1. 形参和实参操作的是同一个数组，不会为形参数组开辟单独的内存空间
	2. 一维数组作形参，可以省略数组长度
	3. 二维数组作形参可以省略行数

## 嵌套和链式访问

1. 可以起嵌套调用但不能嵌套定义
2. 链式访问：一个函数的返回值作为另一个函数的参数

## 声明和定义

1. 同文件可以先声明后定义，函数的定义也是一种特殊的声明
2. 仅声明可以不输入形参名，只声明形参类型
3. 不同文件
	1. .h头文件声明
	2. .c源文件定义：`#include ".h"`

## 变量的作用域：变量的有效范围

1. 全局变量：整个工程
2. 局部变量：{}内

## 变量的生命周期：在内存中创建到销毁的时间

1. 全局变量：整个程序持续期间
2. 局部变量：作用域执行期间

## static

1. 修饰局部变量：使局部变量的生命周期变得和全局变量一样，但是作用域未变化
2. 修饰全局变量：使全局变量只能在本源文件使用，不能在其他源文件使用，哪怕是用extern声明也不行

## extern

- 声明外部符号
	1. 使用其他源文件定义的全局变量时使用
	2. 不能声明static修饰的全局变量

# 函数递归

1. 函数递归：函数自己调用自己
2. 如果死循环，会导致栈溢出Stack overflow
3. 递归：递推→回归
4. 必要条件
   1. 限制条件，即停止条件
   2. 每次调用都会越来越接近这个条件
5. 找出递归的规律
6. 递归层次太深会浪费栈帧空间
7. 有的递归容易造成重复运算：如斐波那契数

# 函数栈帧的创建和销毁

1. 寄存器
   1. eax
   2. ebx
   3. ecx
   4. edx
   5. ebp
   6. esp
2. ebp和esp这两个寄存器存放的是函数的地址
3. 反汇编
   1. push ebp：压栈，将ebp的地址压到内存中，push后esp会跟随变化移动到顶端
   2. mov   ebp，esp：将ebp移动到esp的地址位置
   3. sub    esp，0E4H：将esp的指向的地址减去0E4H
   4. rep stos
      1. ![[Pasted image 20250113171649.png]]
      2. lea      edi，\[ebp+FFFFFF1Ch]：load effective address加载有效地址，将后面的数加载到edi中
      3. 其中mov     ecx，9是将9存到ecx（其实是将ecx的地址移动到地址9）
      4. rep stos命令是将eax中的值赋给edi指向的地址，执行ecx的次数
      5. mov     eax，0CCCCCCCCh是将0CCCCCCCCh存到eax
   5. mov    dword  ptr \[ebp-8], 0Ah：将0Ah放到ebp-8地址处的内存中
   6. call      xxxxxx：将下一条指令进行压栈
   7. pop     edi：出栈

# 调试

1. 调试版本即debug
2. 发布版本即release
3. [VS更多快捷键了解](http://blog.csdn.net/mrlisky/article/details/72622009)
4. 窗口：监视、内存等
5. 程序的栈区内存布局
   1. 从高地址向低地址使用
   2. 数组随下标增长，地址是升高的
6. 编译错误
   1. 编译型错误
      1. 语法错误
      2. 定位简单
   2. 链接型错误：归根到底是未定义
      1. 标识符不存在
      2. 拼写错误
      3. 头文件未包含
      4. 引用的库不存在
   3. 运行时错误：千变万化

# 操作符

## 操作符的分类
1. 算数操作符：+、-、*、/、%
2. 移位操作符：<<、>>
3. 位操作符：&、|
4. 赋值操作符：=、+=、-=、*=、/=、%=、<<=、>>=、&=、|=、^=
5. 单目操作符：!、++、--、&、\*、+、-、~、sizeof(类型)
6. 关系操作符：>、>=、<、<=、\==、!=
7. 逻辑操作符：&&、||
8. 条件操作符：?:
9. 逗号表达式：,
10. 下标引用：[]
11. 函数调用：()
12. 结构成员访问：.、->

## 关系操作符
1. >   <   >=   <=   ==  !=
2. =是赋值操作符，与\==不同
3. 多个关系运算符不宜连用

## 条件操作符：又叫三目操作符
1. exp1?exp2:exp3
2. exp1为真执行exp2，反之执行exp3

## 逻辑操作符
1. !   &&   ||
2. 短路：自左往右依次执行
	1. &&遇到假时，后面放弃执行
	2. ||遇到真时，后面放弃执行

## 二进制转换
1. 其余转2
2. 除以2，余数倒写
3. 2转8：三位一算，0开头，如0153 107
4. 2转16：四位一算，0x开头，如0x12 18
5. 正整数：原、反、补相同
6. 负整数：
	1. 原：翻译成二级制（反码+1）
	2. 反：除符号位取反
	3. 补：反码+1
7. 浮点数没有原反补码的概念
8. 二进制运算的时候符号位也参与运算，然后补码转换原码取反+1的时候，因为符号位经过运算了，为1就继续求原码（这时取反要保留符号位），0就代表他运算结果是正整数不用求了

## 移位操作符：仅限整数
1. <<左移：算数左移，右侧补0，左侧舍弃
2. >>右移：移动逻辑由编译器决定
	1. 逻辑右移，左侧补0，右侧舍弃
	2. 算数右移，左侧补符号，右侧舍弃
3. 不能移负数位

## 位操作符：仅限整数

1. &：按位与，11为1
2. |：按位或，00为0
3. ^：按位异或，相同为0相异为1
	1. 支持交换律
	2. 任何数与0按位与或都为这个数本身
4. ~：按位取反，直接取反

## 单目操作符：
- !  ++  --  &  *  +  -  ~  sizeof()
## 逗号表达式：exp1,exp2,exp3

1. 自左向右依次执行
2. 最后输出的结果是exp3的结果

## 下标访问、函数调用

1. []：下标访问，只有取值的时候才是下标访问符号，定义数组是不是，arrp\[0]的操作数为arr和0
2. ()：同下标访问，add(x)的操作数为add和x，可以没有参数x

## 结构体成员操作符

1. 结构体[[C语言#结构体]]
2. 直接访问：.直接访问结构体内部成员
3. 间接访问：\*通过结构体的指针访问结构体内部成员

## 操作符属性：[优先级和结合性](https://zh.cppreference.com/w/c/language/operator_precedence)

## 表达式求值

1. 整型提升
	1. 意义：CPU内整型操作数标准长度和int字节的长度相同，所以char类型运算时，要将char的字节长度提升为int类型的字节长度，而int转char时直接截断
	2. 过程：提升→运算→截断→存储
	3. 无符号提升，高位补0，有符号提升，高位补1
	4. char的二进制的最高位也是符号位，为1的时候仍要推算原码
2. 算术转换：下列下方和上方混合运算时，要转换成上方的
	1. long double
	2. double
	3. float
	4. unsigned long int
	5. long int
	6. unsigned int
	7. int
3. 建议不要写出复杂的表达式，只通过结合性和优先级是无法确定唯一计算路径的，是存在风险的

# 指针

## 内存和地址

1. 内存划分为一个个的内存单元，每个单元大小取1个字节，即8比特位
2. 给每个内存单元编号，CPU通过这个编号快速找到内存空间
3. 这个编号也叫做地址，C语言中称为指针
4. 这个编号是通过硬件设计完成的：总线传递内存和CPU的信息
	1. 地址总线：32位系统32根2^32个地址，64位系统64根2^64个地址
	2. 数据总线
	3. 控制总线

## 指针变量和地址

1. &：取地址操作符，只取类型所占字节中较小的地址
2. 指针变量
	1. type\* name=&a
	2. 类型：type \*
		1. \*表示这是指针变量
		2. type表示这是指针变量指向的变量类型
		3. 去掉名字就是类型
	3. 大小：32位系统32bit，64位系统64bit，与类型无关
3. \*：解引用操作符
	1. 配合type，决定了解引用能够访问的字节大小，
		1. ⽐如： char* 的指针解引⽤就只能访问⼀个字节，⽽ int* 的指针的解引⽤就能访问四个字节
		2. 指针的类型决定了，对指针解引⽤的时候有多⼤的权限（⼀次能操作⼏个字节

## void\*指针

   1. 将int变量的指针赋给char\*类型的指针变量，会报警
	1. void\*可以接受任何类型的变量的指针
	2. 使用在函数参数的部分，接收不同类型的地址

## const

1. 修饰变量，让变量无法被修改，这时可以通过指针修改
2. 修饰指针变量
	1. const在\*左侧会让\*p无法修改
	2. const在\*右侧会让p无法修改

## 指针运算
1. 指针+-整数
	1. 本质上就是，指针+-（整数*指针类型）
	2. 指针类型决定了指针向前或向后走一步的距离
	3. 地址+整数\*szieof(type)
2. 指针-指针
3. 指针的关系运算

## 野指针：指向的位置不可知

1. 成因
	1. 指针未初始化
	2. 指针越界访问：如数组
	3. 指针指向的空间释放：如函数返回值为临时指针变量
2. 如何规避
	4. 初始化：NULL
	5. 避免越界
	6. 不使用时，及时置NULL，NULL地址为0
	7. 使用前，检查有效性
	8. 避免返回局部指针变量

## assert断言

- assert.h
- assert()宏
- 如果指针为真，则程序继续运行，为假则报错
- release可以设置自动优化，vs2022默认自动优化
	- 在assert.h头文件上一行加`#define NDEBUG`

## 传值和传址

1. 传值调用：如果要不修改实参，只是利用实参进行运算，可以直接传值
2. 传址调用：如果要修改实参，要进行传址调用

## 数组名

- 数组名就是数组第一个元素的地址
- sizof(arr)中arr不是第一个元素的地址，表示整个数组，二维数组名也一样，二维数组中的一维数组名也一样
- &arr代表整个数组的地址，所以&arr+1跨过的是整个数组的长度

## 指针访问数组

- \*(p+i)\==p\[i],两者是完全等价的
- 同理也可以写成i\[p]

## 一维数组传参的本质

- 本质上传的是数组首个元素的地址
- 所以无法在函数内部求数组的个数
- 形参部分可以写成数组的形式，也可以写成指针的形式

## 二级指针

- 存放指针变量的地址
- int a;int\*p=&a;int* *pp=&p;
- \*\*a\==a

## 指针数组

- 用来存放指针的数组
- int* p\[10]:p是数组名，类型是int* \[10]
- 指针数组模拟二维数组
	- 将多个一维数组的首地址存到一个指针数组中，可以用来模拟二维数组

## 字符指针变量

- char*
- const char* ptr = "hello world",存放的是常量字符串首字符h的地址，因为常量字符串是不能更改的，所以在星号前加const修饰

## 数组指针变量

- 存放的是数组的地址
- 类型：int (\*p) \[常量值] = &arr
- int\[常量值]是指向数组的类型
- p是指针名
- \*代表p是指针

## 二维数组传参的本质

- 首先数组名遵守规则：数组名为数组首元素的地址
- 二维数组可以理解为一维数组的集合，其首元素为一维数组
- 所以二维数组的数组名本质上是一维数组的地址，即是一个数组指针，type (\*p)\[10]
- 所以二维数组传参，形参的部分可以写成数组，也可以写成指针
- \*和&是可以相互抵消的，\*&arr\==arr

## 函数指针变量

- 函数是存在地址的
- 函数名\==&函数名，两者都是代表函数的地址，完全相同
- 3.type (\*p)(int x,int y)
	- type：函数的返回值
	- p：指针名字
	- \*：代表这是个指针
	- (int x,int y)：函数的形参，xy可省略
- 4.解引用：\*p\==\*&函数名\==函数名
	- p\==&函数名\==函数名
	- 所以p\==\*p

## typedef关键字

- (\*(void (\*)())0)();
- void (\*signal(int , void(\*)(int)))(int);
	- 声明了一个函数
	- 返回值：void (\*)(int)
	- 名字：signal
	- 形参：int，void(\*)(int)
- 3.typedef unsigned int unit;
	- unsigned int a=0;
	- unit a=0;
	- 二者等价

```C++
typedef unsigned int unit;//无符号变量
typedef int (*arr_p)[5];//数组指针
typedef int (*fun_p)(int,int);//函数指针
typedef int* p_arr[5];//指针数组
```

## 函数指针数组

```C
//假设有是三个返回值为整型的函数，现在创建一个函数指针数组
//函数指针
int (*p1)()=fun1;
//函数指针数组
int (*p[3])()={fun1,fun2,fun3};
```

## 回调函数

    1.通过函数指针调用的函数
	2.qsort()排序模拟实现
		1.void*的使用
		2.一个字节一个字节的交换数据

## sizeof和strlen的对比

    1.sizeof：操作符
		1.单位：字节
		2.只关注大小
		3.不参与计算，只是根据类型判断所占字节大小
			所以不存在数组访问越界的问题
	2.strlen：库函数
		1.求字符串长度
		2.遇到\0才终止
		3.结果为\0之前的字符总长度（即字符串长度）
		4.形参为字符串首字符的地址
			size_t strlen ( const char * str )

# 字符函数和字符串函数

## 字符分类函数

| 函数：ctype.h（但是已经包含在stdio.h里面了） | 符合条件就返回真（即不等于0的值）                              |
| :------------------------------------------- | -------------------------------------------------------------- |
| iscntrl                                      | 任何控制字符：0~31以及127号字符                                |
| isspace                                      | 空白字符：空格、换行\n、换页\f、回车\r、制表符\t、垂直制表符\v |
| isdigit                                      | 十进制数字：0~9                                                |
| isxdigit                                     | 十六进制数字：0~9，a\~f，A\~F                                  |
| islower                                      | 小写字母                                                       |
| isupper                                      | 大写字母                                                       |
| isalpha                                      | 字母                                                           |
| isalnum                                      | 字母或者数字                                                   |
| ispunct                                      | 任何可打印的不属于数字或者字母的图形字符                       |
| isgraph                                      | 任何图形字符                                                   |
| isprint                                      | 任何可打印字符（包括图形字符和空白字符）                       |

## 字符转换函数

- tolower
- toupper

## [strlen](https://cplusplus.com/reference/cstring/strlen/?kw=strlen)

1. 头文件：string.h但已经包含在stdio.h中了
2. 以'\0'为结束标志，返回之前的字符个数
3. 返回值类型是size_t无符号整型
4. strlen的模拟实现

## [strcpy](https://legacy.cplusplus.com/reference/cstring/strcpy/?kw=strcpy)

1. 源字符串必须以字符'\0'结束，会将'\0'拷贝过去（'\\0'也是拷贝结束的判断依据）
2. 目标字符串空间要足够大且能修改
3. strcpy的模拟实现

## [strcat](https://legacy.cplusplus.com/reference/cstring/strcat/?kw=strcat)

1. 源字符串必须以'\\0'结束
2. 目标字符串也必须有'\\0'，追加结束后添加一个'\\0'
3. 目标空间足够大
4. 目标空间可修改
5. strcat模拟实现
6. 追加自己后果：原字符串的'\\0'标志会被替换，无法中止

## [strcmp](https://legacy.cplusplus.com/reference/cstring/strcmp/?kw=strcmp)

1. 原理：比较字符的ASCII值的大小
2. 当高位比较结果出来时，后续就不用比了，同整数运算一样
3. strcmp模拟实现
4. 返回值是整型

## [strncpy](https://legacy.cplusplus.com/reference/cstring/strncpy/?kw=strncpy)

1. 从源拷贝n个字符到目标字符串
2. 如果n大于源字符串长度不够的用0替代
3. 最后不会追加'\\0'

## [strncat](https://legacy.cplusplus.com/reference/cstring/strncat/?kw=strncat)

1. 无论n多大，遇到源字符串的'\\0'就会停止了
2. 最后会追加一个'\\0'

## [strncmp](https://legacy.cplusplus.com/reference/cstring/strncmp/?kw=strncmp)

1. 同strcmp一样，只不过是限定了位数

## [strstr](https://legacy.cplusplus.com/reference/cstring/strstr/?kw=strstr)

1. 在一个字符串中查找另一个字符串
2. 返回第一个查找到的地址，若没有则返回NULL
3. 匹配不包含字符'\\0'
4. 必须包含头文件string.h

## [strtok](https://legacy.cplusplus.com/reference/cstring/strtok/?kw=strtok)

1. 第一次形参需要输入要读取的数组和符号数组的地址，然后返回第一个遇到的符号地址，并将读好改为'\\0'
2. 之后输入NULL，符号数组的地址
3. 如果不存在符号了则返回NULL
4. 因为会修改数组，所以最好读取的时候复制一个数组来进行读取

## [strerror](https://legacy.cplusplus.com/reference/cstring/strerror/?kw=strerror)

1. 首先程序启动时会默认有一个全局变量int erron，默认为0，出现错误时会给erron赋值
2. strerror(erron)会返回erron对应的错误描述字符串
3. perror为printf+sterror的集合

# 内存函数

## [memcpy](https://legacy.cplusplus.com/reference/cstring/memcpy/?kw=memcpy)

1. 从source位置复制n个字节到dest位置(n为字节数)
2. 会复制'\\0'
3. 如果source字符不够，补0
4. 如果字节有余数，忽略掉
5. 标准情况下，如果源和目标有重叠怎结果未定义（但有的编译器做的好，结果是可以的）
6. 模拟实现
7. 重叠对象使用memmove实现

## [memmove](https://legacy.cplusplus.com/reference/cstring/memmove/?kw=memmove)

1. 同memcpy
2. 可以处理有重叠的两块内存

## [memset](https://legacy.cplusplus.com/reference/cstring/memset/?kw=memset)

1. 设置内存，将指定的字节设置成想要的值
2. 模拟实现

## [memcmp](https://legacy.cplusplus.com/reference/cstring/memcmp/?kw=memcmp)

1. 比较ASCII值
2. 模拟实现

# 数据在内存中的存储

## 整数在内存中的存储

1. [整数的二进制存储](C语言.md#操作符)
   1. 大端存储：低位存在高地址
   2. 小端存储：低位存在低地址

## 浮点数在内存中的存储

1. foat、double、long double
2. V=(-1)^S\*M\*2^E

| Type | 符号位S  | 指数位E   | 有效数字M        |
| ---- | ----- | ------ | ------------ |
| 32位  | 1/bit | 8/bit  | 23/bit       |
| 64位  | 1/bit | 11/bit | 52/bit<br /> |

3. 规则
   * S：0或1
   * E：存时+127，取时-127（64位+-1023）
     * 因为E是无符号整数，但是实际是可能出现负数的，所以进行补偿
     * E没有符号位所以是无符号整数
     * 例如8bit时，通过+127补偿就能够存 -127~128
   * M：舍去整数1，小数点后填入，不够位数向后补0
4. 特殊情况
   * E全为0：E==1-127，M不再+1
   * E全为1，M全为0：表示±无穷

# 结构体
## 定义：
1. 多个变量的结合
2. 可以是不同类型
3. 名字不是地址
## 声明：
4. `struct tag{Member_List}variable_list;`
5. 可以在末尾创建变量并声明
6. 可以在最后创建指针，但是需要对其单独分配内存
## 初始化
7. 按照顺序
8. 乱序：`{.MemberName2=,.MemberName1=,}`
9. 注意：结构体和数组一样，创建时可以用大括号初始化，后面就不能再用大括号初始化了
## 特殊声明：匿名结构体
10. 省略名字
11. 只能声明时创建，即只能使用一次
## 结构体自引用
12. 不能使用名字进行自引用，大小会无穷大
13. 只能创建本类型的指针进行自引用
14. 匿名结构体不能定义自引用
## 结构体内存对齐
15. 起始位置的偏移量为0
16. 第一个成员对齐到0
17. 其他成员：
	1. 对齐数：变量大小和系统对齐数取**较小值**
		1. VS默认为8
		2. Linux中为变量自身的大小
		3. 
	2. 对齐到偏移量为该变量大小的整数倍处
18. 结构体总大小为最大对齐数（此处指经过取较小值后的对齐数）的倍数
19. 结构体内嵌的情况下，内嵌结构体的对齐数取其成员的最大对齐数
20. 为什么存在内存对齐
	1. 平台原因（移植原因）：某些硬件平台只能在某些地址处去某些特定类型的数据
	2. 性能原因：对齐可以使一个数据在能够被一个内存单位放下的时候不被分割，即拿空间换时间
	3. 所以让空间小的成员尽量集中在一起
21. 可以修改默认对齐数：
	1. pragma pack(n)：
	2. n=1,2,4,8,16.....
## 结构体传参
22. 因为结构体一般都挺大
23. 传值调用需要为形参单独开辟内存空间不合适
24. 所以结构体使用传址调用合适
25. 传址调用能实现传值调用的一切功能
## 位段
1. 成员必须是：int、unsigned int、signed、char（c99可以是其他类型）
2. 成员后必须有一个冒号和一个代表占多少bite的数字
3. 分配原则：按变量顺序分配，逐个变量类型计算（比如int类型最小就开辟4个字节），剩余比特位能放下下一个就合并，不能就重新开辟字节
4. 遵循对齐原则，合并的变量按照一个变量计算
5. 注意：
	1. int有无符号没有标准
	2. 位段中最大数目不能确定，写27位在16位机器就会出问题
	3. 在内存中从左向右还是从右向左分配没有标准
	4. 剩余位不能容纳下一个，舍弃与否没有标准
6. 因为会公用字节所以不能取地址，想通过scanf赋值，可以通过中间变量
# 联合体
## 概念
1. 同结构体一样，但是所有变量公用一块内存空间，又叫共用体
2. 所以联合体中一个变量变化，其他所有变量都会跟着变化
## 联合体内存存放
1. 大小为至少为最大成员的大小
2. 大小要是最大对齐数的整数倍
3. 数组其实就是这个类型的变量依次存放
4. 数组的最大对齐数就是这个类型的变量的最大对齐数
5. 联合体的大小要是最大对齐数的整数倍
## 联合体的作用
1. 有若干个对象
2. 这些对象有共同的属性，但是也有不同的属性
3. 就可以创建结构体，共同属性正常创建，不同属性以联合体作为结构体的成员
# 枚举
## 定义
```C
enum En
{
one,
two,
three,
}；
```
1. 成员叫做枚举常量
2. 这些取值默认从0开始，依次递增1
3. 注意定义的时候内部分隔符是逗号
4. 不能用scanf输入值
## 优点
1. 增加代码的可读性和可维护性
2. 枚举有类型检查，比#define更严谨
3. 便于调试，#define定义的符号会在预处理阶段被删除
4. 比#define使用方便，一次可定义多个
5. 枚举遵循作用域规则，#define全局生效
# 动态内存管理
## 概念
1. 在内存的堆区开辟一块连续可以用的内存
2. 必须由程序员自己申请和释放，否则开辟后就只能程序结束后才能释放，所以很容易造成内存泄漏
## malloc
1. 向内存申请一块连续可用的空间
2. 开辟成功返回指向这块空间的指针
3. 失败则返回NULL指针
4. 返回类型为void*
## free
1. 释放开辟的内存
2. 传递的形参必须是动态内存的指针，如果不是会报错
3. 传递的形参如果是NULL，函数不会执行逻辑
4. PS：释放后立即将该指针设为NULL，否则会形成野指针
## calloc
1. 同alloc，唯一不同的是会把开辟空间的字节都初始化为0
## realloc
1. 赋予了动态内存这个概念意义
2. 通过realloc可以修改动态内存的空间大小
3. 使用时两种情况
	1. 原空间后有足够空间：直接追加，原空间数据不发生变化
	2. 原空间后没有足够空间：另找一片空间，返回一个新的指针，并将数据迁移过去
		1. 也会开辟失败，返回空指针
		2. 所以使用时不要直接将返回值赋予之前的指针
4. realloc也可以直接使用，形参输入NULL，当做malloc使用
## 动态内存常见错误
1. 对NULL指针解引用
2. 对动态空间越界访问
3. 对非动态空间指针free释放
4. 使用free释放动态内存的一部分
5. 对同一块内存多次释放（所以释放后要及时将指针置NULL，这样free就不会有动作）
6. 动态内存忘记释放（内存泄漏）
	- 最容易出现，因为在函数内部开辟后，一出函数，若果没有返回开辟空间的指针和在内部释放就会导致内存泄漏
## 柔性数组
### 概念
1. 结构体中的数组
2. 其前面必须有个其他变量
3. 不计算在结构体的大小之内
4. 结构体中声明柔性数组，不输入数组的大小即可
## 柔性数组的使用
1. 创建结构体时就不能按照常规方法了，要创建这个结构体类型的指针变量
2. 定义柔性数组时有两种方法
	1. 直接在结构体声明数组
	2. 在结构体中声明一个该数组类型的指针变量
	3. 两种方法比较：第一种好
		1. 方便释放内存
			如果写在函数中，并把结构体返回给别人，别人只知道free结构体，并不知道free结构体里面的内存
		2. 减少内存碎片（因为第二种方法的内存会不连续，用的多了，开辟的内存空间会有一段段的间隔导致浪费和访问变慢），提高访问速度
3. [C语言结构体里的成员数组和指针 | 酷 壳 - CoolShell](https://coolshell.cn/articles/11377.html)
## C/C++中程序内存区域划分
![[Pasted image 20250218010138.png|700]]
1. 栈区stack：内存容量有限，程序自动释放
2. 堆区heap：程序员手动申请和释放，若不释放，程序结束时OS释放，类似于链表
3. 数据段（静态区）：存放全局变量、static修饰的局部变量和静态数据
4. 代码段（常量区）：存放函数体的二级制代码
# 文件
## 文件概念
1. 磁盘/硬盘上的文件
## 文件分类
1. 程序文件：
	1. 源文件.c
	2. 目标文件.obj
	3. 可执行程序.exe
2. 数据文件：程序运行时读写的文件
## 文件名
1. 唯一标识
2. 文件名
	1. 路径
		1. 绝对路径：C:\\XX\\XXX.TXT
		2. 相对路径：.\\..\\
			1. .\：本级目录
			2. ..\：上级目录
	2. 文件名主干
	3. 后缀
## 数据文件分类
1. 文本文件：以ASCII的形式存储的文件就是文本文件
2. 二进制文件：数据在内存中是二进制形式，不加转换存储到数据文件中就是二进制文件
---
## 流和标准流
1. 流：程序针对文件、键盘、屏幕等的输入输出操作都是通过流操作的，流属于程序和外部设备的中转
2. 标准流：C语言程序启动时默认打开三个流
	1. stdin：标准输入流：大都从键盘输入，如scanf
	2. stdout：标准输出流：大都输出到显示器，如printf
	3. stderr：标注错误流：大都输出到显示器
## 文件指针
1. 每个被使用的文件都在内存中开辟了一个相应的文件信息区，这些信息保存在一个结构体变量中，取名FILE
2. 通过 **FILE\*** 类型的指针可以操作这个文件
```C
struct _iobuf 
{ 
	char *_ptr; 
	int _cnt; 
	char *_base;
	int _flag; 
	int _file; 
	int _charbuf; 
	int _bufsiz; 
	char *_tmpfname; 
}; typedef struct _iobuf FILE;
```
## 文件的打开和关闭
1. fopen
2. fclose
3. 下方变革中的命令，使用后光标都会停留在最终操作的位置，若要从头操作需要重置光标位置

| 文件使用方式<br> | 含义                 | 如果文件不存在 |
| ---------- | ------------------ | ------- |
| "r"        | 只读                 | 出错      |
| "w"        | 只写                 | 新建      |
| "a"        | 只写，在文本尾部追加         | 新建      |
| "r+"       | 可读可写，写从头开写，保留未覆盖内容 | 出错      |
| "w+"       | 可读可写，写的时候清空从头开写    | 新建      |
| "a+"       | 可读可写，写从文件尾写        | 新建      |
| 二进制        |                    |         |
| "rb"       |                    |         |
| "wb"       |                    |         |
| "ab"       |                    |         |
| "rb+"      |                    |         |
| "wb+"      |                    |         |
| "ab+"      |                    |         |

## 文件读写函数
### 顺序读写

| 函数名<br> | 功能                       | 适用于   |
| :------ | :----------------------- | :---- |
| fgetc   | 非格式化字符输入                 | 所有输入流 |
| fputc   | 非格式化字符输出                 | 所有输出流 |
| fgets   | 非格式化字符串输入，读取个数-1，最后一个补\0 | 所有输入流 |
| fputs   | 非格式化字符串输出，遇到\0终止         | 所有输出流 |
| fscanf  | 格式化输入                    | 所有输入流 |
| fprintf | 格式化输出                    | 所有输出流 |
| fread   | 二进制格式化输入                 | 文件输入流 |
| fwrite  | 二进制格式化输出                 | 文件输出流 |

| 函数名            | 适用于                                            |
| -------------- | ---------------------------------------------- |
| scanf/printf   | 标准输入输出流                                        |
| fscanf/fprintf | 所有输入输出流                                        |
| sscanf/sprintf | 将各种数据转换成字符，输入输出字符数组，<br>sscanf必须按照sprintf的顺序进行 |
### 随机读写


| 函数名    | 作用                       |
| ------ | ------------------------ |
| fseek  | 根据文件指针，偏移量，光标初始位置来确定光标位置 |
| ftell  | 返回文件光标相对于其实位置的偏移量        |
| rewind | 将光标返回起始位置                |
## 文件读取结束的判定
1. 文件结束判定：错误时会设置一个错误标识符，末尾时会设置一个末尾标识符，分别用下面两个函数检测
	1. feof：一旦遇到末尾标识符，返回非0，否则返回0
	2. ferror：一旦遇到错误标识符，返回非0，否则返回0
2. 判断文件读取是否结束

| 函数名<br> | 返回值                                              |
| :------ | :----------------------------------------------- |
| fgetc   | 成功返回ascii值，结束返回eof（不管是遇到末尾还是错误，但两者设置的指示符不同）      |
| fgets   | 成功则返回字符串的地址<br>结束返回NULL(不管是遇到末尾还是错误，但两者设置的指示符不同) |
| fread   | 返回读取的字节个数，如果比设置的小则说明结束                           |
## 文件缓冲区
1. ![[Pasted image 20250219172619.png|381]]
2. C语言在操作文件的时候，需要做刷新缓冲区或者在文件结束的时候关闭文件，否则可能会导致读写文件的问题
3. 刷新缓存区就是讲内存中的数据更新到硬盘中
4. 关闭文件也会刷新缓存区
5. 保存文件就是在刷新缓存区，好让内存的数据保存到硬盘内
# 编译和链接
![[Pasted image 20250223031221.png|581]]
![[Pasted image 20250223031540.png|581]]
## 翻译环境和运行环境
 1. 在[ANSI C](https://baike.baidu.com/item/ANSI%20C/7657277)的任何实现都存在两个不同环境
	 1. 翻译环境：将源代码转成机器指令（二级制）
	 2. 运行环境：执行实际代码
## 翻译环境
1. 构成
	1. 编译
		1. 预处理
		2. 编译
		3. 汇编
	2. 链接
2. 过程
	1. 经过预处理生成.i文件：gcc -E test.c -o test.i
		1. 删除#define并展开所有宏定义
		2. 处理条件编译指令#if、#ifdef等
		3. 处理#include预编译指令，递归进行，被包含的头文件可能包含其他文件
		4. 删除注释
		5. 添加行号和文件名标识
	2. 编译：gcc -S test.i -o test.s
		1. 词法分析：代码→记号，如关键字、标识符、字面量、特殊字符
		2. 语法分析：以表达式为节点的语法树
		3. 语义分析及优化：声明、类型匹配、类型转换、报告错误的语法信息
	3. 汇编：gcc -c test.s -o test.o
		1. 将汇编代码转换成二机器可执行的指令
	4. 将一堆文件链接在一起生成可执行程序
		1. 地址、空间分配、符号决议、重定位
		2. 解决项目中多文件、多模块的相互调用
## 重定位
1. 每个源文件都是单独经过编译器生成对应的目标文件
2. 用到其他文件的中的函数、变量等时，先给一个空地址
3. 所有文件进行链接时，相同名的函数、变量合并塌陷，地址为这些函数、变量声明定义的文件编译是赋予的地址
## 运行环境
1. 程序必须载入内存
	1. 有操作系统的环境由操作系统完成
	2. 独立环境，手动载入或者将可执行代码置入只读内存
2. 程序执行：调用main函数
3. 执行程序代码
	1. 运行时堆栈：存储函数的局部变量和返回值
	2. 静态内存：执行过程中保留静态区的值
4. 终止程序
	1. 正常终止main函数
	2. 意外终止
## 预处理
### 预定义符号
1. C语言设置的，可直接使用
```C
__FILE__//文件名
__LINE__//行号
__DATE__//日期
__TIME__//时间
__STDC__//编译器是否遵循ANSI C，遵循为1，否则未定义
```
### \#define定义注意事项
1. \#define其实就是原封不动的将定义的代码替换过去
2. 所以不要在最后加;，不然可能会出现语法错误
### \#define定义宏
#### 注意事项
1. 参数左括号要紧挨宏名字，不然会认定为宏内容的一部分
2. 宏内容能加括号就加，不然会出现优先级问题
3. a++这种属于带有副作用的参数
4. 不能出现递归
```C
#define name(param_list) stuff
param_list：参数列表
```
#### 宏和函数对比
简单运算使用宏，复杂运算使用函数

| 属性      | 宏              | 函数            |
| ------- | -------------- | ------------- |
| 代码长度    | 长：每次使用都会把宏代码插入 | 短：只出现在定义的地方一次 |
| 执行速度    | 快              | 慢：栈帧          |
| 操作符优先级  | 有影响，所以加括号      | 无副作用          |
| 带副作用的参数 | 有影响            | 无副作用          |
| 参数类型    | 无限制            | 有限制           |
| 调试      | 不方便调试          | 可逐语句调试        |
| 递归      | 不可递归           | 可递归           |
| 传递类型    | 可以传递类型         | 不可传递类型        |
#### \#和\#\#
1. "\#a"→“a”
2. type##\_int→type_int
### 命名约定
1. 宏名全部大写（但不绝对）
2. 函数名不要全部大写
### \#undef
移除一个宏定义
### 命令行定义
1. 不定义标识符SZ
2. 命令行定义：gcc -D SZ=10 programe.c
### 条件编译
- 种类
	- 通过符号是否被定义判断
	- 通过常量值是否为真判断
- 可多分支
- 可嵌套
### 头文件包含
- “”
	- 现在源文件目录寻找，如果未找到就在标准位置查找
	- 库函数也可以用这个但是效率会变低
- <>
	- 直接去标准路径查找
	- Linux：/usr/include
	- Windows：C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include
- 避免头文件重复引用
	- pragma once
	- 条件编译